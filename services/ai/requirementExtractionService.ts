import { GoogleGenAI, Type } from "@google/genai";
import { JiraTask, Requirement, RequirementAIAnalysis, TestCase, STLCPhaseName } from '../../types';
import { detectCurrentSTLCPhase } from '../../utils/stlcPhaseDetector';
import { Project } from '../../types';

const API_KEY = import.meta.env.VITE_GEMINI_API_KEY || import.meta.env.GEMINI_API_KEY;

let ai: GoogleGenAI | null = null;

if (API_KEY) {
  ai = new GoogleGenAI({ apiKey: API_KEY });
} else {
  console.warn("GEMINI_API_KEY environment variable not set. Some features may not work.");
}

const getAI = () => {
  if (!ai) {
    throw new Error("GEMINI_API_KEY não configurada. Por favor, configure a variável de ambiente VITE_GEMINI_API_KEY.");
  }
  return ai;
};

const requirementExtractionSchema = {
  type: Type.OBJECT,
  properties: {
    requirements: {
      type: Type.ARRAY,
      items: {
        type: Type.OBJECT,
        properties: {
          title: {
            type: Type.STRING,
            description: "Título do requisito extraído"
          },
          description: {
            type: Type.STRING,
            description: "Descrição detalhada do requisito"
          },
          type: {
            type: Type.STRING,
            enum: ["Funcional", "Não Funcional"],
            description: "Tipo do requisito"
          },
          priority: {
            type: Type.STRING,
            enum: ["Baixa", "Média", "Alta", "Urgente"],
            description: "Prioridade do requisito"
          },
          acceptanceCriteria: {
            type: Type.ARRAY,
            items: { type: Type.STRING },
            description: "Critérios de aceitação do requisito"
          },
          stlcPhase: {
            type: Type.STRING,
            enum: [
              "Análise de Requisitos",
              "Planejamento de Testes",
              "Desenvolvimento de Casos de Teste",
              "Execução de Testes",
              "Encerramento do Teste"
            ],
            description: "Fase do STLC associada ao requisito"
          }
        },
        required: ["title", "description", "type", "priority", "acceptanceCriteria", "stlcPhase"]
      }
    }
  },
  required: ["requirements"]
};

const requirementAnalysisSchema = {
  type: Type.OBJECT,
  properties: {
    qualityScore: {
      type: Type.NUMBER,
      description: "Score de qualidade de 0 a 100"
    },
    completeness: {
      type: Type.STRING,
      description: "Análise de completude do requisito"
    },
    clarity: {
      type: Type.STRING,
      description: "Análise de clareza do requisito"
    },
    testability: {
      type: Type.STRING,
      description: "Análise de testabilidade do requisito"
    },
    suggestedImprovements: {
      type: Type.ARRAY,
      items: { type: Type.STRING },
      description: "Melhorias sugeridas para o requisito"
    },
    detectedGaps: {
      type: Type.ARRAY,
      items: { type: Type.STRING },
      description: "Gaps detectados no requisito"
    }
  },
  required: ["qualityScore", "completeness", "clarity", "testability", "suggestedImprovements", "detectedGaps"]
};

const testCaseMatchingSchema = {
  type: Type.OBJECT,
  properties: {
    matches: {
      type: Type.ARRAY,
      items: {
        type: Type.OBJECT,
        properties: {
          requirementId: {
            type: Type.STRING,
            description: "ID do requisito"
          },
          testCaseIds: {
            type: Type.ARRAY,
            items: { type: Type.STRING },
            description: "IDs dos casos de teste que correspondem ao requisito"
          },
          confidence: {
            type: Type.NUMBER,
            description: "Nível de confiança do match (0-100)"
          },
          reasoning: {
            type: Type.STRING,
            description: "Razão do match"
          }
        },
        required: ["requirementId", "testCaseIds", "confidence", "reasoning"]
      }
    }
  },
  required: ["matches"]
};

/**
 * Extrai requisitos de uma tarefa usando IA
 */
export async function extractRequirementsFromTask(
  task: JiraTask,
  project: Project
): Promise<Omit<Requirement, 'id' | 'createdAt' | 'updatedAt' | 'status' | 'relatedTasks' | 'testCases' | 'sourceTaskId' | 'autoGenerated' | 'aiAnalysis'>[]> {
  const currentPhase = detectCurrentSTLCPhase(project);
  const testCasesInfo = task.testCases.map(tc => ({
    description: tc.description,
    expectedResult: tc.expectedResult,
    status: tc.status,
  }));

  const prompt = `
Você é um especialista em QA e engenharia de requisitos. 
Analise a tarefa fornecida e extraia todos os requisitos funcionais e não funcionais que podem ser identificados.

TAREFA:
- Título: ${task.title}
- Descrição: ${task.description || 'Sem descrição'}
- Tipo: ${task.type}
- Prioridade: ${task.priority || 'Não definida'}
- Casos de Teste: ${JSON.stringify(testCasesInfo, null, 2)}

FASE ATUAL DO STLC: ${currentPhase}

INSTRUÇÕES:
1. Extraia todos os requisitos identificáveis da tarefa (pode ser 0, 1 ou múltiplos requisitos).
2. Para cada requisito, identifique:
   - Título claro e descritivo
   - Descrição detalhada
   - Tipo (Funcional ou Não Funcional)
   - Prioridade baseada na prioridade da tarefa e importância do requisito
   - Critérios de aceitação baseados na descrição e casos de teste
   - Fase do STLC mais apropriada
3. Se a tarefa não contém requisitos claros, retorne array vazio.
4. Seja específico e baseado nos dados fornecidos.
5. Use português brasileiro.

Respeite o schema JSON fornecido.
  `;

  try {
      const response = await getAI().models.generateContent({
        model: "gemini-2.5-flash",
        contents: [{ text: prompt }],
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: requirementExtractionSchema as any,
        },
      });

    const parsedResponse = JSON.parse(response.text.trim());
    return parsedResponse.requirements || [];
  } catch (error) {
    console.error('Erro ao extrair requisitos da tarefa:', error);
    throw error;
  }
}

/**
 * Analisa a qualidade de um requisito usando IA
 */
export async function analyzeRequirementQuality(
  requirement: Requirement,
  project: Project
): Promise<RequirementAIAnalysis> {
  const allTestCases = project.tasks.flatMap(t => t.testCases || []);
  const relatedTestCases = allTestCases.filter(tc => requirement.testCases.includes(tc.id));
  
  const prompt = `
Você é um especialista em qualidade de requisitos. 
Analise o requisito fornecido e avalie sua qualidade, completude, clareza e testabilidade.

REQUISITO:
- ID: ${requirement.id}
- Título: ${requirement.title}
- Descrição: ${requirement.description}
- Tipo: ${requirement.type}
- Prioridade: ${requirement.priority}
- Critérios de Aceitação: ${JSON.stringify(requirement.acceptanceCriteria, null, 2)}
- Fase STLC: ${requirement.stlcPhase}
- Status: ${requirement.status}
- Casos de Teste Vinculados: ${relatedTestCases.length}

CASOS DE TESTE VINCULADOS:
${relatedTestCases.map(tc => `- ${tc.description} (Status: ${tc.status})`).join('\n') || 'Nenhum caso de teste vinculado'}

INSTRUÇÕES:
1. Avalie a qualidade geral do requisito (score de 0 a 100).
2. Analise a completude: verifique se tem todos os elementos necessários (descrição, critérios de aceitação, etc.).
3. Analise a clareza: avalie se a descrição é clara e compreensível.
4. Analise a testabilidade: verifique se o requisito pode ser testado efetivamente.
5. Sugira melhorias específicas e acionáveis.
6. Detecte gaps (ex: falta de critérios de aceitação, falta de casos de teste, descrição vaga, etc.).
7. Use português brasileiro.
8. Seja específico e construtivo.

Respeite o schema JSON fornecido.
  `;

  try {
      const response = await getAI().models.generateContent({
        model: "gemini-2.5-flash",
        contents: [{ text: prompt }],
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: requirementAnalysisSchema as any,
        },
      });

    const parsedResponse = JSON.parse(response.text.trim());
    
    return {
      ...parsedResponse,
      generatedAt: new Date().toISOString(),
    };
  } catch (error) {
    console.error('Erro ao analisar qualidade do requisito:', error);
    throw error;
  }
}

/**
 * Faz matching inteligente entre casos de teste e requisitos usando IA
 */
export async function matchTestCasesToRequirements(
  requirements: Requirement[],
  testCases: TestCase[],
  project: Project
): Promise<Array<{ requirementId: string; testCaseIds: string[]; confidence: number; reasoning: string }>> {
  if (requirements.length === 0 || testCases.length === 0) {
    return [];
  }

  const requirementsInfo = requirements.map(req => ({
    id: req.id,
    title: req.title,
    description: req.description,
    acceptanceCriteria: req.acceptanceCriteria,
    type: req.type,
  }));

  const testCasesInfo = testCases.map(tc => ({
    id: tc.id,
    description: tc.description,
    expectedResult: tc.expectedResult,
    steps: tc.steps,
  }));

  const prompt = `
Você é um especialista em rastreabilidade de requisitos (RTM). 
Analise os requisitos e casos de teste fornecidos e faça um matching inteligente entre eles.

REQUISITOS:
${JSON.stringify(requirementsInfo, null, 2)}

CASOS DE TESTE:
${JSON.stringify(testCasesInfo, null, 2)}

INSTRUÇÕES:
1. Para cada requisito, identifique quais casos de teste validam esse requisito.
2. Um caso de teste pode validar múltiplos requisitos.
3. Um requisito pode ser validado por múltiplos casos de teste.
4. Considere a descrição, critérios de aceitação e resultados esperados.
5. Forneça um nível de confiança (0-100) para cada match.
6. Explique o raciocínio do match.
7. Seja conservador: só faça match se houver relação clara.
8. Use português brasileiro.

Respeite o schema JSON fornecido.
  `;

  try {
      const response = await getAI().models.generateContent({
        model: "gemini-2.5-flash",
        contents: [{ text: prompt }],
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: testCaseMatchingSchema as any,
        },
      });

    const parsedResponse = JSON.parse(response.text.trim());
    return parsedResponse.matches || [];
  } catch (error) {
    console.error('Erro ao fazer matching de casos de teste:', error);
    throw error;
  }
}

